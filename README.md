# Практическая работа по курсу «Архитектура ПО». Спринт 1

## Задание № 1

### Уровень 1. Проектирование

**Учитывая что:**

* Single SPA является хотя и более мощным, но в то же время значительно более сложным для интеграции и сопровождения решением;

* Размеры проекта (даже Module Federation для него избыточен);

* Далеко не самый высокий уровень квалификации в работе с фронтендом и отсутствие релевантного опыта у разработчика (здесь я имею в виду себя), которому предстоит на практике осуществить разделение на микрофронтенды;

* Условно говоря, подсказку данную в разделе курса «Как сдать проектную работу на уровне запуска кода».

**Решено:**

В данном задании для разделения имеющегося фронтненда на 2 микрофронтенда применить Webpack плагин Module Federation.

### Уровень 2. Планирование изменений

#### Организационный план

Поскольку в курсе нам был представлен пример разбиения проекта, составить организационный план перевода проекта Mesto на микрофронтенды было достаточно просто.

1. Перевести *shell* (оригинальный фронтенд) на webpack
2. Создать внутри директории frontend/microfrontend 2 проекта: profile и pics
3. Разнести функционал из frontend/src/Utils
4. Предварительно разнести компоненты
5. Научить profile работать самостоятельно
6. Научить pics работать самостоятельно
7. Подключить компоненты profile к *shell*
8. Подключить компоненты pics к *shell*

По факту воплощения в жизнь пункты 6 и 7 поменялись местами.

#### О технических решениях

Кратко остановимся на значимых для 2-го уровня задания технических решениях.

На этапе 3 мы планировали провести рефакторинг исходного Utils. В результате принятых изменений модуль auth полностью перешёл в микрофронтенд profile. В то же самое время оригинальный класс api был разделён на 2 одноимённых независимых класса, по одному для каждого микрофронтенда.

Класс, который появился в микрофронтенде profile, получил следующие методы

* getUserInfo
* setUserInfo
* setUserAvatar

А класс в микрофронтенде pics:

* getCardList
* addCard
* removeCard
* changeLikeCardStatus

Метод *getAppInfo* ожидаемо никуда не вошёл за ненадобностью.

На следующем, 4-ом этапе мы должны были предварительно распределить имеющиеся компоненты React между т.н. shell приложением и 2-мя созданными нами микрофронтендами. Обозначим для удобства литерами, к какому новому самостоятельному проекту компонент будет относиться:

* S — shell,
* P — profile,
* X — pics.

```bash
$ tree src/components/
src/components/
├── AddPlacePopup.js     X
├── App.js               S
├── Card.js              X
├── EditAvatarPopup.js   P
├── EditProfilePopup.js  P
├── Footer.js            S
├── Header.js            P
├── ImagePopup.js        X
├── InfoTooltip.js       P
├── Login.js             P
├── Main.js              S
├── PopupWithForm.js     PX
├── ProtectedRoute.js    P
└── Register.js          P
```

Анализ кода показал, что от компонента PopupWithForm, зависимыми оказались некоторые компоненты, перешедшие в оба микрофронтенда, в следствие чего потребовалось копию данного компонента поместить в каждый микрофронтенд.

### Уровень 3. Запуск готового кода

Как выяснилось, чтобы убедиться в работоспособности новой версии приложения (Module Federation), код бэкенда, имеющийся в репозитории проекта не нужен. К счастью, кто-то (дай, Господи, ему всех благ) догадался запустить некий «тестовый» бэкенд на nomoreparties.co. Это в значительной степени облегчило нашу задачу.

Помимо PopupWithForm, мне представилось целесообразным включить компонент ProtectedRute как в profile, так и в shell, изменив при этом логику следующим образом. Я убрал из «глобального» состояния переменную isLoggedIn, а для проверки того, что пользователь авторизован, стал использовать наличие токена в LocalStorage.

Также в микрофронтенде profile компонент Header был переименован для однозначности в ProfileHeader, и добавлены следующие компоненты:

* Profile — для имитации структуры основного приложения (чтобы независимая разработка и ручное тестирование микрофронтенда могла проводится в условиях, приближенных к «боевым»),
* ProfileWrapper — также для имитации структуры,
* ProfileBlock — компонент, агрегирующий несколько мелких связанных компонентов с целью более удобного экспорта-импорта в shell,
* Stub — просто заглушка для начальной проверки правильности настройки Module Federation.

В микрофронтенде pics, помимо перешедших их оригинального фронтенда компонентов, мной были добавлены:

* Pics — для имитации структуры основного приложения,
* PicsBlock — по аналогии с ProfileBlock, агрегирующий компонент,
* AddPlaceButton — кнопка, инициирующая открытие модального диалога добавления места,
* PicsStub — заглушка.

В целом, пришлось осуществить переработку большинства компонентов, направленную на локализацию логики, т.е. на инкапсуляцию поведения непосредственно в сами компоненты.

Хотел бы отметить, что применённая в исходном проекте практика синхронизации состояния компонентов посредством вызова нативного для JS метода dispatchEvent мне показалась несколько неуместной. Как я уже отмечал, я не являюсь опытным (и даже неопытным) фронтенд-разработчиком. Весьма непродолжительный поиск в интернете подтвердил мои опасения: работа React базируется на т.н. [„synthetic events“](https://react.dev/reference/react-dom/components/common#react-event-object). А смешивать 2 типа событий без крайней на то необходимости, мне представляется не совсем правильно. Поэтому я попробовал ещё поискать, как люди, разбирающиеся во фронтенде, решают подобные задачи. Мне попался репозиторий с примерами, который создали авторы Module Federation:

<https://github.com/module-federation/module-federation-examples>

Собственно говоря, по мотивам примера [shared-context](https://github.com/module-federation/module-federation-examples/tree/master/shared-context) мне удалось с Божией помощью реализовать данное решение. Для этого я добавил разделяемую (между всеми 3 частями проекта) библиотеку (frontend/microfrontend/context-library).

Справедливости ради, следует отметить, что я так же рассматривал вариант с управлением состоянием через store и reducers. В данном проекте посчитал достаточным использование 2-х разделяемых контекстов, по 2 переменных в каждом (хотя можно было сделать и 4 — для каждой переменной свой), но в реальном приложении, скорее всего, задействовал бы [Effector](https://effector.dev/ru/).

#### Как запустить приложение

Следует открыть 3 вкладки (или окна) терминала. Перейти в соответствующую директорию относительно корня проекта:

1. frontend/microfrontend/pics
2. frontend/microfrontend/profile
3. frontend

В каждой директории запустить `$ npm install`. Затем в этой же последовательности запустить в каждой вкладке `$ npm run start`. Когда всё запустится, открыть в броузере [http://localhost:3000/](http://localhost:3000/).

## Задание № 2

Ссылка на файл: <https://disk.yandex.ru/d/s6j6x3niaUod-w>

Диаграмма с микросервисами находится на странице «Микросервисы». Описание сервисов и потоков — на странице «Описание». Прошу прощения за то, что нумерация потоков несплошная, это в значительной степени облегчило процесс, условно говоря, проектирования.
